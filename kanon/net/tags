!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Channel	Channel.h	/^	Channel(EventLoop* loop, int fd)$/;"	f	class:kanon::Channel
Channel	Channel.h	/^class Channel {$/;"	c	namespace:kanon
ChannelMap	PollerBase.h	/^	typedef kanon::map<int, Channel*> ChannelMap;$/;"	t	class:kanon::PollerBase
ChannelVec	PollerBase.h	/^	typedef std::vector<Channel*> ChannelVec;$/;"	t	class:kanon::PollerBase
Event	Channel.h	/^	enum Event {$/;"	g	class:kanon::Channel
EventCallback	Channel.h	/^	typedef std::function<void()> EventCallback;$/;"	t	class:kanon::Channel
EventLoop	type.h	/^typedef EventLoopT<Epoller> EventLoop;$/;"	t	namespace:kanon
EventLoop	type.h	/^typedef EventLoopT<Poller> EventLoop;$/;"	t	namespace:kanon
EventLoopT	EventLoop.h	/^class EventLoopT : noncopyable {$/;"	c	namespace:kanon
EventLoopT	EventLoop_impl.h	/^EventLoopT<T>::EventLoopT()$/;"	f	class:kanon::EventLoopT
KANON_CHANNEL_H	Channel.h	2;"	d
KANON_NET_CALLBACK_H	callback_type.h	2;"	d
KANON_NET_EVENTLOOP_H	EventLoop.h	2;"	d
KANON_NET_EVENTLOOP_IMPL_H	EventLoop_impl.h	2;"	d
KANON_NET_TYPE_H	type.h	2;"	d
KANON_POLLER_H	PollerBase.h	2;"	d
NoneEvent	Channel.h	/^		NoneEvent = 0$/;"	e	enum:kanon::Channel::Event
POLLTIME	EventLoop.h	18;"	d
PollerBase	PollerBase.h	/^	explicit PollerBase(EventLoopT<Poller>* loop)$/;"	f	class:kanon::PollerBase
PollerBase	PollerBase.h	/^class PollerBase : noncopyable {$/;"	c	namespace:kanon
ReadEvent	Channel.h	/^		ReadEvent = POLLIN | POLLPRI,$/;"	e	enum:kanon::Channel::Event
WriteEvent	Channel.h	/^		WriteEvent = POLLOUT,$/;"	e	enum:kanon::Channel::Event
_GNU_SOURCE	Channel.h	6;"	d
activeChannels_	EventLoop.h	/^	std::vector<Channel*> activeChannels_;$/;"	m	class:kanon::EventLoopT
channelMap_	PollerBase.h	/^	ChannelMap channelMap_;$/;"	m	class:kanon::PollerBase
close_callback	Channel.h	/^	void close_callback(EventCallback cb) { close_callback_ = std::move(cb); }$/;"	f	class:kanon::Channel
close_callback_	Channel.h	/^	EventCallback close_callback_;$/;"	m	class:kanon::Channel
error_callback_	Channel.h	/^	EventCallback error_callback_;$/;"	m	class:kanon::Channel
ev2String	Channel.cc	/^std::string Channel::ev2String(int ev) {$/;"	f	class:kanon::Channel
events_	Channel.h	/^	int events_;$/;"	m	class:kanon::Channel
events_handling_	Channel.h	/^	bool events_handling_;$/;"	m	class:kanon::Channel
fd_	Channel.h	/^	int fd_;$/;"	m	class:kanon::Channel
handleEvents	Channel.cc	/^void Channel::handleEvents() {$/;"	f	class:kanon::Channel
hasChannel	PollerBase.h	/^	bool hasChannel(Channel* ch) {$/;"	f	class:kanon::PollerBase
index_	Channel.h	/^	uint32_t index_;$/;"	m	class:kanon::Channel
kanon	Channel.cc	/^namespace kanon {$/;"	n	file:
kanon	Channel.h	/^namespace kanon {$/;"	n
kanon	EventLoop.h	/^namespace kanon {$/;"	n
kanon	EventLoop_impl.h	/^namespace kanon {$/;"	n
kanon	PollerBase.h	/^namespace kanon {$/;"	n
kanon	callback_type.h	/^namespace kanon {$/;"	n
kanon	type.h	/^namespace kanon {$/;"	n
log_hup_	Channel.h	/^	bool log_hup_;$/;"	m	class:kanon::Channel
loop	EventLoop_impl.h	/^void EventLoopT<T>::loop() {$/;"	f	class:kanon::EventLoopT
loop_	Channel.h	/^	EventLoop* loop_;$/;"	m	class:kanon::Channel
loop_	PollerBase.h	/^	EventLoopT<Poller>* loop_;$/;"	m	class:kanon::PollerBase
looping_	EventLoop.h	/^	bool looping_;$/;"	m	class:kanon::EventLoopT
noexcept	EventLoop.h	/^	bool isLoopInThread() noexcept;$/;"	m	class:kanon::EventLoopT
noexcept	EventLoop.h	/^	void abortNotInThread() noexcept;$/;"	m	class:kanon::EventLoopT
noexcept	EventLoop.h	/^	void assertInThread() noexcept;$/;"	m	class:kanon::EventLoopT
noexcept	EventLoop.h	/^	void quit() noexcept;$/;"	m	class:kanon::EventLoopT
ownerThreadId_	EventLoop.h	/^	const pid_t ownerThreadId_;$/;"	m	class:kanon::EventLoopT
poller_	EventLoop.h	/^	std::unique_ptr<PollerBase<T>> poller_;$/;"	m	class:kanon::EventLoopT
quit_	EventLoop.h	/^	bool quit_;		$/;"	m	class:kanon::EventLoopT
read_callback_	Channel.h	/^	EventCallback read_callback_;$/;"	m	class:kanon::Channel
removeChannel	PollerBase.h	/^	void removeChannel(Channel* ch) {$/;"	f	class:kanon::PollerBase
revents_	Channel.h	/^	int revents_;$/;"	m	class:kanon::Channel
set_error_callback	Channel.h	/^	void set_error_callback(EventCallback cb) { error_callback_ = std::move(cb); }$/;"	f	class:kanon::Channel
set_read_callback	Channel.h	/^	void set_read_callback(EventCallback cb) { read_callback_ = std::move(cb); }$/;"	f	class:kanon::Channel
set_write_callback	Channel.h	/^	void set_write_callback(EventCallback cb) { write_callback_ = std::move(cb); }$/;"	f	class:kanon::Channel
update	Channel.cc	/^void Channel::update() {$/;"	f	class:kanon::Channel
updateChannel	EventLoop_impl.h	/^inline void EventLoopT<T>::updateChannel(Channel* ch) {$/;"	f	class:kanon::EventLoopT
updateChannel	PollerBase.h	/^	void updateChannel(Channel* ch) {$/;"	f	class:kanon::PollerBase
write_callback_	Channel.h	/^	EventCallback write_callback_;$/;"	m	class:kanon::Channel
